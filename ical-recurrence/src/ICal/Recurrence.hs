{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE RecordWildCards #-}

-- | ICal Recurrence
--
-- This module exists to help you canculate the recurrence set of an event.
--
-- [section 3.8.5](https://datatracker.ietf.org/doc/html/rfc5545#section-3.8.5)
--
-- @
-- The following properties specify recurrence information in calendar
-- components.
-- @
--
-- [section 3.8.5.1](https://datatracker.ietf.org/doc/html/rfc5545#section-3.8.5.1)
--
-- @
-- The recurrence set is the complete
-- set of recurrence instances for a calendar component.  The
-- recurrence set is generated by considering the initial "DTSTART"
-- property along with the "RRULE", "RDATE", and "EXDATE" properties
-- contained within the recurring component.
-- [...]
-- The final recurrence set is generated by gathering all of the
-- start DATE-TIME values generated by any of the specified "RRULE"
-- and "RDATE" properties, and then excluding any start DATE-TIME
-- values specified by "EXDATE" properties.
-- @
--
-- However, because recurrence sets can be infinite, we do not reify
-- them and instead provide only functions that produce finite results.
module ICal.Recurrence
  ( RecurringEvent (..),
    Recurrence (..),
    EventOccurrence (..),
    recurEvents,
    recurRecurrenceDateTimes,
    recurRecurrenceRules,
    removeExceptionDatetimes,
  )
where

import Control.Monad.Reader
import Data.Set (Set)
import qualified Data.Set as S
import Data.Time
import Data.Validity
import GHC.Generics (Generic)
import ICal.Property
import ICal.PropertyType
import qualified ICal.PropertyType.DateTimes as DateTimes

data Recurrence = Recurrence
  { recurrenceExceptionDateTimes :: Set ExceptionDateTimes,
    recurrenceRecurrenceDateTimes :: Set RecurrenceDateTimes,
    recurrenceRecurrenceRules :: Set RecurrenceRule
  }
  deriving (Show, Eq, Generic)

instance Validity Recurrence

data RecurringEvent = RecurringEvent
  { recurringEventStart :: !(Maybe DateTimeStart),
    recurringEventEndOrDuration :: !(Maybe (Either DateTimeEnd Duration)),
    recurringEventRecurrence :: !Recurrence
  }
  deriving (Show, Eq, Generic)

instance Validity RecurringEvent

data EventOccurrence = EventOccurrence
  { eventOccurrenceStart :: !(Maybe DateTimeStart),
    eventOccurrenceEndOrDuration :: !(Maybe (Either DateTimeEnd Duration))
  }
  deriving (Show, Eq, Ord, Generic)

instance Validity EventOccurrence

-- | Compute the recurrence set, up to a given limit
recurEvents :: LocalTime -> RecurringEvent -> Set EventOccurrence
recurEvents limit RecurringEvent {..} =
  let -- @
      -- The "DTSTART" property for a "VEVENT" specifies the inclusive
      -- start of the event.  For recurring events, it also specifies the
      -- very first instance in the recurrence set.
      -- @
      -- @
      -- The "DTSTART" property
      -- defines the first instance in the recurrence set.
      -- @
      startEvent =
        EventOccurrence
          { eventOccurrenceStart = recurringEventStart,
            eventOccurrenceEndOrDuration = recurringEventEndOrDuration
          }
   in case recurringEventStart of
        Nothing -> S.singleton startEvent
        Just startDateTime ->
          let Recurrence {..} = recurringEventRecurrence
              occurrencesFromRecurrenceDateTimes = recurRecurrenceDateTimes startDateTime recurringEventEndOrDuration recurrenceRecurrenceDateTimes
              occurrencesFromRecurrenceRules = recurRecurrenceRules limit startDateTime recurringEventEndOrDuration recurrenceRecurrenceRules
              -- @
              -- The final recurrence set is generated by gathering all of the
              -- start DATE-TIME values generated by any of the specified "RRULE"
              -- and "RDATE" properties, and then excluding any start DATE-TIME
              -- values specified by "EXDATE" properties.
              -- @
              -- @
              -- Where duplicate instances are generated by the "RRULE"
              -- and "RDATE" properties, only one recurrence is considered.
              -- Duplicate instances are ignored.
              -- @
              preliminarySet = S.union occurrencesFromRecurrenceDateTimes occurrencesFromRecurrenceRules
           in removeExceptionDatetimes recurrenceExceptionDateTimes preliminarySet

-- | Compute the occurrences that the recurrence date times imply
recurRecurrenceDateTimes ::
  DateTimeStart ->
  Maybe (Either DateTimeEnd Duration) ->
  Set RecurrenceDateTimes ->
  Set EventOccurrence
recurRecurrenceDateTimes dateTimeStart endOrDuration recurrenceDateTimess =
  S.unions $
    flip S.map recurrenceDateTimess $
      let withNewStart newStart =
            EventOccurrence
              { eventOccurrenceStart = Just newStart,
                eventOccurrenceEndOrDuration = resolveEndOrDurationDate dateTimeStart endOrDuration newStart
              }
       in \case
            RecurrenceDates dates ->
              S.map
                (withNewStart . DateTimeStartDate)
                dates
            RecurrenceDateTimes dateTimes ->
              S.map
                (withNewStart . DateTimeStartDateTime)
                (DateTimes.toSet dateTimes)
            RecurrencePeriods periods ->
              S.map
                ( \case
                    PeriodStartEnd start end ->
                      EventOccurrence
                        { eventOccurrenceStart = Just $ DateTimeStartDateTime (DateTimeUTC start),
                          eventOccurrenceEndOrDuration = Just (Left (DateTimeEndDateTime (DateTimeUTC end)))
                        }
                    PeriodStartDuration start duration ->
                      EventOccurrence
                        { eventOccurrenceStart = Just $ DateTimeStartDateTime (DateTimeUTC start),
                          eventOccurrenceEndOrDuration = Just (Right duration)
                        }
                )
                periods

resolveEndOrDurationDate ::
  DateTimeStart ->
  Maybe (Either DateTimeEnd Duration) ->
  DateTimeStart ->
  Maybe (Either DateTimeEnd Duration)
resolveEndOrDurationDate originalStart mEndOrDuration newStart = case mEndOrDuration of
  Nothing -> Nothing
  Just (Right duration) -> Just (Right duration)
  Just (Left end) ->
    -- @
    -- If the duration of the recurring component is specified with the
    -- "DTEND" or "DUE" property, then the same exact duration will apply
    -- to all the members of the generated recurrence set.  Else, if the
    -- duration of the recurring component is specified with the
    -- "DURATION" property, then the same nominal duration will apply to
    -- all the members of the generated recurrence set and the exact
    -- duration of each recurrence instance will depend on its specific
    -- start time.  For example, recurrence instances of a nominal
    -- duration of one day will have an exact duration of more or less
    -- than 24 hours on a day where a time zone shift occurs.  The
    -- duration of a specific recurrence may be modified in an exception
    -- component or simply by using an "RDATE" property of PERIOD value
    -- type.
    -- @
    case (originalStart, end) of
      (DateTimeStartDate startDate, DateTimeEndDate endDate) ->
        let exactDuration = diffDates startDate endDate
         in case newStart of
              DateTimeStartDate newDate -> Just (Left (DateTimeEndDate (dateAddDays exactDuration newDate)))
              _ -> undefined "Exact duration offsets are not supported yet."
      (DateTimeStartDateTime startDateTime, DateTimeEndDate endDateTime) ->
        undefined "Exact duration offsets are not supported yet."
      -- These two cases represent invalid ical:
      -- @
      -- The "VEVENT" is also the calendar component used to specify an
      -- anniversary or daily reminder within a calendar.
      -- These events
      -- have a DATE value type for the "DTSTART" property instead of the
      -- default value type of DATE-TIME.  If such a "VEVENT" has a "DTEND"
      -- property, it MUST be specified as a DATE value also.
      -- @
      -- However, this is a new restriction, see the following, so we do
      -- _something_ in this case, to not have to error.
      --
      -- In the section: "A.1. New Restrictions":
      -- @
      -- The value type of the "DTEND" or "DUE" properties MUST match the
      -- value type of "DTSTART" property.
      -- @
      (DateTimeStartDate startDate, DateTimeEndDateTime endDateTime) ->
        let -- Note that this generous interpretation comes with the very false
            -- assumption that timezones are not relevant to dates.
            --
            -- TODO do this with a test case.
            duration = diffDates startDate (dateTimeDate endDateTime)
         in case newStart of
              DateTimeStartDate newDate ->
                Just (Left (DateTimeEndDate (dateAddDays duration newDate)))
              _ -> undefined "Exact duration offsets are not supported yet."
      (DateTimeStartDateTime startDateTime, DateTimeEndDate endDate) ->
        undefined "Exact duration offsets are not supported yet."

-- For cases where a "VEVENT" calendar component
-- specifies a "DTSTART" property with a DATE value type but no
-- "DTEND" nor "DURATION" property, the event's duration is taken to
-- be one day.  For cases where a "VEVENT" calendar component
-- specifies a "DTSTART" property with a DATE-TIME value type but no
-- "DTEND" property, the event ends on the same calendar date and
-- time of day specified by the "DTSTART" property.

-- | Compute the occurrences that the recurrence rules imply
--
-- TODO implement this:
-- @
-- The recurrence set generated with multiple "RRULE" properties is
-- undefined.
-- @
recurRecurrenceRules ::
  -- | Limit
  LocalTime ->
  DateTimeStart ->
  Maybe (Either DateTimeEnd Duration) ->
  Set RecurrenceRule ->
  Set EventOccurrence
recurRecurrenceRules = undefined

-- TODO about why we need the start date
-- @
-- Information, not contained in the rule, necessary to determine the
-- various recurrence instance start time and dates are derived from
-- the Start Time ("DTSTART") component attribute.  For example,
-- "FREQ=YEARLY;BYMONTH=1" doesn't specify a specific day within the
-- month or a time.  This information would be the same as what is
-- specified for "DTSTART".
-- @

-- TODO about invalid dates:
-- @
-- Recurrence rules may generate recurrence instances with an invalid
-- date (e.g., February 30) or nonexistent local time (e.g., 1:30 AM
-- on a day where the local time is moved forward by an hour at 1:00
-- AM).  Such recurrence instances MUST be ignored and MUST NOT be
-- counted as part of the recurrence set.
-- @

-- TODO About computing end and duration:
-- @
-- If the duration of the recurring component is specified with the
-- "DTEND" or "DUE" property, then the same exact duration will apply
-- to all the members of the generated recurrence set.  Else, if the
-- duration of the recurring component is specified with the
-- "DURATION" property, then the same nominal duration will apply to
-- all the members of the generated recurrence set and the exact
-- duration of each recurrence instance will depend on its specific
-- start time.  For example, recurrence instances of a nominal
-- duration of one day will have an exact duration of more or less
-- than 24 hours on a day where a time zone shift occurs.  The
-- duration of a specific recurrence may be modified in an exception
-- component or simply by using an "RDATE" property of PERIOD value
-- type.
-- @

-- | Remove the occurrences that the exception date times imply should be removed
removeExceptionDatetimes ::
  Set ExceptionDateTimes ->
  Set EventOccurrence ->
  Set EventOccurrence
removeExceptionDatetimes = undefined

data RecurCtx = RecurCtx {recurCtxLimit :: LocalTime}
  deriving (Show, Eq)

type R = Reader RecurCtx
